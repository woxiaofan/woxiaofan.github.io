<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[particles]]></title>
      <url>%2F2017%2F03%2F03%2Fparticles%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie的常用操作]]></title>
      <url>%2F2017%2F02%2F27%2Fcookie%2F</url>
      <content type="text"><![CDATA[JavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。而cookie是运行在客户端的，所以可以用JS来设置cookie。 假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ 首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie假设在A页面中要保存变量username的值(“yyf”)到cookie中,key值为name，则相应的JS代码为： 1document.cookie = "name=" + yyf; 假设需要加上过期时间，方法如下：123456function setCookie(name,value)&#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000);//时间戳以毫秒为单位 document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString();&#125; JS读取cookie假设cookie中存储的内容为：username=yyf;password=123 则在B页面中获取变量username的值的JS代码如下：12var username=document.cookie.split(";")[0].split("=")[1];//则该username获取结果为yyf 注意：上述方法仅指明确cookie的数据数目和顺序的情况下才可使用，比如自己设置的或者通过浏览器查看后的页面。若是一个陌生页面，则应该通过如下万能法 123456789function getCookie(cName)&#123; var cookieArr = document.cookie.split(";");//将cookie通过分号分割，存为一个名为cookieArr的数组 for (var i=0; i &lt; cookieArr.length; i++)&#123; var cookieVal = cookieArr[i].split("=");//遍历数组，将每一个cookie的key和value通过等于号分割，存为一个名为cookieVal的数组 if (cName == cookieVal[0]) return unescape(cookieVal[1]);//将value值解密后拿出 &#125; return null;&#125; 删除cookies1234567function delCookie(name)&#123; var exp = new Date(); exp.setTime(exp.getTime() - 1);//将本地时间戳设置为不存在的一个时间即可 var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString();&#125; jQuery-Cookie插件 jQuery.cookie.js是个很好的cookie插件，包括设置、删除、获取等一系列完整的cookie操作 创建会话cookie（Session cookie，既浏览器内存cookie，浏览器关闭后自动删除） 1$.cookie('the_cookie', 'the_value'); 创建一个生生存周期为7天的cookie 1$.cookie('the_cookie', 'the_value', &#123; expires: 7 &#125;); 创建一个有期限的cookie，整个站点可以读取 1$.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); 读取cookie 12$.cookie('the_cookie'); // =&gt; "the_value"$.cookie('not_existing'); // =&gt; undefined 读取所有可用cookie 1$.cookie(); // =&gt; &#123; "the_cookie": "the_value", "...remaining": "cookies" &#125; 删除cookie 1234// 找到指定的cookie返回true，否则返回false$.removeCookie('the_cookie');// 删除指定过path的cookie$.removeCookie('the_cookie', &#123; path: '/' &#125;); $.cookie(’name’, ‘value’, {expires: 7, path: ‘/’, domain: ‘jquery.com’, secure: true}); (1)读取cookie值 $.cookie(cookieName) cookieName:要读取的cookie名称。 示例：$.cookie(&quot;username&quot;); 读取保存在cookie中名为的username的值。 (2)写入设置Cookie值： $.cookie(cookieName,cookieValue); cookieName:要设置的cookie名称，cookieValue表示相对应的值。 示例:$.cookie(&quot;username&quot;,&quot;admin&quot;); 将值&quot;admin&quot;写入cookie名为username的cookie中。 $.cookie(&quot;username&quot;,NULL); 销毁名称为username的cookie (3)[option]参数说明： expires: 有限日期，可以是一个整数或一个日期(单位：天)。 这个地方也要注意，如果不设置这个东西，浏览器关闭之后此cookie就失效了 path: cookie值保存的路径，默认与创建页路径一致。 domin: cookie域名属性，默认与创建页域名一样。 这个地方要相当注意，跨域的概念，如果要主域名二级域名有效则要设置 &quot;.xxx.com&quot; secrue: 一个布尔值，表示传输cookie值时，是否需要一个安全协议。 另外更多操作详情点击API文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百听不厌的经典歌曲]]></title>
      <url>%2F2017%2F01%2F16%2Fmusic%2F</url>
      <content type="text"><![CDATA[柔和抒情：❤激情澎湃：❤❤ 外文歌英文 Pixie Paris - Es Rappelt lm Karton ❤ Tonya Mitchell - stay ❤ Madonna - La Isla Bonita ❤ Carly Rae Jepsen、Owl City - Good Time Leo Sayer - More Than I Can Say Lenka - Troble Is A Friend Maxwell - It’s Ok ❤❤ Jessie J - Flashlight Maria Arredondo - Buring ❤❤ Atomic Kitten - If You Come To Me A-Teens - Firefly Backstreet Boys - As Long As You Love Me Lene Marlin - A Place Nearby ❤ Tata Young - I Think Of You Lenka - The Show ❤ Groove Coverage - Far Away From Home Lenka - Blue Skies ❤ Westlife - Season In The Sun ❤ M2M - The Day You Went Away ❤ Westlife - Nothing’s Gonna Change My Love For You Mark Ronson、bruno Mars - Uptown Funk ❤❤ Westlife - My Love Michael Learns to Rock - Take Me To Your Heart ❤❤ Gareth Gates - Anyone Of Us(stupid Mistake) Deutschland Sucht Den Superstar - Cry On My Shoulder Groove Coverage - She ❤ 曲婉婷 - Drenched Darin - B What U Wanna B 韩文 淑熙 - 啦啦啦 Cnblue - ひとりぼっち(孤独的人) ❤❤ 星 - Sha La La ❤ T Ara - Cry Cry T-Ara - Day By Day 日文 GARNET CROW - Mysterious Eyes ❤ GARNET CROW - Misty Mystery ❤❤ rikki - 素敵だね ❤ いきものがかり - ブルーバード(青鸟) ❤❤ 宇多田ヒカル - First Love ❤ 中文歌国语 蔡依林 - 海盗 单小源、本兮 - 你在看孤独的风景❤ 周二珂 - 告白气球 ❤原唱：周杰伦 周杰伦 - 晴天 F4 - 流星雨 李健 - 贝加尔湖畔 ❤ 至上励合 - 棉花糖 薛之谦 - 丑八怪 吉克隽逸 - 爱情发的光 毛泽少 - 没有眼泪的鱼 简弘亦 - 情义盖过天 游鸿明 - 诗人的眼泪 游鸿明 - 白色恋人 ❤ 王心凌 - 还是好朋友 张杰 - 我们都一样 牛奶咖啡 - 明天,你好 ❤ 韩红 - 那片海 周杰伦 - 米兰的小铁匠 杜雯媞、王艺翔 - 雪 陈奕迅 - 不要说话 梁静茹 - 给未来的自己 刘涛 - 红颜旧 吴雨霏 - 生生世世爱 ❤❤ 王力宏 - 我们的歌 李荣浩 - 不将就 筷子兄弟 - 父亲 王力宏 - 需要人陪 ❤ 萧亚轩 - 类似爱情 丁浩然 - 离开以后 毛阿敏 - 相思 ❤ 张靓颖 - 我们说好的 东来东往 - 多一个人陪伴 ❤ 青鸟飞鱼 - 此生不换 粤语 陈奕迅 - 浮夸 ❤❤ Twins - 下一站天后 ❤]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BootStrap框架常用语法]]></title>
      <url>%2F2017%2F01%2F08%2Fbootstrap-common%2F</url>
      <content type="text"><![CDATA[文档结构 需要使用HTML5文档结构 &lt;!DocType html&gt; 移动设备优先 需要在头部增加&lt;meta&gt;标签 1&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,initial-scale=1.0"/&gt; 引入BootStrap 引入css，当有自己的css文档，应引入bootstrap.css后再引入自己编写额css文件 引入jQuery.js再引入bootstrap.js 若要兼容IE浏览器，再引入两个js文件，使用IE的条件注释 &lt;!--[if lt IE 9]&gt;&lt;script&gt;...&lt;/script&gt;&lt;script&gt;...&lt;/script&gt;&lt;![endif]--&gt; [两个js文件自己google] bootstrap表单样式创建表单步骤： 1.创建form标签并添加role=&quot;form&quot;(语义化，给浏览器和搜索引擎看) 2.控制分组，把标签和控件放在一个class为formgroup的div中 3.给表单控件(input,textarea,select)添加类名form-control 内联表单 给form添加类名form-inline 水平表单 给form添加类名form-horizontal 给标签label添加类名control-label 配合bootstrap网格系统加入类名col-sm-1 其它表单控件 form-control-static：静态表单控件，添加标签和类名，不必用input特定标签 help-block：表单提示，添加标签和类名（同上） 提示图标：glyphicon glyphicon-ok（参照API文档） form-control-feedback 按钮：在使用其它类名前均加上基础类名btn 基础类名：btn 默认按钮样式：btn-default 原始按钮样式：btn-primary 成功按钮样式：btn-success 链接式按钮：btn-link ----------------------- 设置按钮大小 超大：btn-lg 默认大小：btn-md 小号：btn-xs btn-block：块级按钮，宽度取决于它父级的宽度的100% ----------------------- 设置按钮状态 激活：active 禁用：disable bootstrap图片样式响应式图片 img-responsive（max-width:100%） 圆角图片 img-rounded img-circle 圆形 缩略图 img-thumbnail：添加一个内边距padding和边框 bootstrap辅助类 左浮动：pull-left 右浮动：pull-right 块级并居中：center-block 需要设置宽度，不能设浮动 强制元素显示/隐藏：show/hide 隐藏文字：text-hide bootstrap表格样式 基础类名：table table-striped：斑马线表格 table-bordered：带边框表格（给td加边框） table-hover：鼠标悬停高亮效果 table-condensed：紧凑型表格（减少单元格padding值） table-responsive：响应式表格 bootstrap网格系统原理 将容器平分为12份（12列）结合媒体查询做出响应式布局效果 用法 定义一个.row的容器作为行定义一个.col的容器作为列只有col才能作为row的直接子元素 屏幕 屏幕尺寸 .col-lg-* 超大 &gt;1200px .col-md-* 中屏 &gt;992px .col-sm-* 小屏 &gt;768px .col-xs-* 超小 &lt;768px *代表1~12，每一个所占空间大小 列偏移&amp;列排序 列偏移：不希望两列靠在一起，使用类名.col-*-offset-* 列排序：设置网格的排列顺序 .col-*-push-* 往右排 .col-*-pull-* 往左排 通俗点就是往左移动和往右移动几个网格空间大小 bootstrap下拉菜单 创建一个类名为dropdown的div容器，用它来包裹整个下拉菜单 在dropdown容器内添加一个按钮button，作为父菜单 定义类名为dropdown-toggle和自定义属性data-toggle=&quot;dropdown&quot; 添加按钮里的小三角 button添加类名为caret的span标签 创建下拉菜单 添加一个ul无序列表，定义类名为dropdown-menu 菜单分割线 添加一个空列表项li，类名为divider bootstrap按钮组将几个按钮放入一个类名为btn-group的div中 btn-group-vertical ☞ 垂直按钮组 按钮组大 ☞ 给组别加类名btn-group-lg|md|sm|xs 嵌套按钮组 在按钮组里面嵌套下拉列表 在btn-group里面嵌套一个btn-group，将下拉菜单的父菜单按钮放置在嵌套的btn-group里 给父菜单按钮添加类名dropdown-toggle和自定义属性data-toggle=”dropdown” 增加小三角图标&lt;span class=&#39;caret&#39;&gt;&lt;/span&gt; bootstrap导航 添加无序列表，用来作为导航 给列表添加类名 .nav ☞ 基础类名 nav-tabs ☞ 表格式导航 nav-pills ☞ 鼓囊式导航 给导航菜单项添加样式 active ☞ 当前选中项 disabled ☞ 禁用状态 ☞ 垂直式导航：给导航添加类名nav-stacked 一般用于鼓囊式导航 ☞ 导航二级菜单：在导航里添加下拉列表 1. 给父级菜单添加类名dropdown 2. 在此列表项里添加一个二级菜单列表项 .dropdown-menu 3. 给此列表里面的a标签添加类名dropdown-toggle和自定义属性data-toggle=&quot;dropdown&quot; ☞ tab标签页导航（选项卡功能） 1. 添加一个表格式导航 2. 给导航里面的a标签添加属性data-toggle=&quot;tab&quot;的锚点链接地址 3. 添加一个tab-content的div，在里面包含每一个要切换的tab标签页 4. 给每一个标签页添加类名tab-pane和fade 5. 默认显示项 - 给导航列表项添加类名active - 给默认显示标签页添加类名active和in ☞ 导航条 导航条头部里面可以放置导航，表单等 1. 添加类名为navbar的div，用来制作导航条 navbar-default ☞ 默认 navbar-inverse ☞ 反色 2. 在navbar里面添加页面标题 添加一个类名为navbar-head的div，包含navbar-brand的a标签 3. 在navbar里添加导航 在普通导航基础上添加类名navbar-nav 4. 导航里添加表单（搜索框） 添加类名navbar-form PS：将搜索框和按钮用类名为input-group的div包起来，将搜索按钮放入类名为input-group-btn的span中，可实现搜索框和按钮连在一起的视觉效果 5. 导航条里的浮动 navbar-left ☞ 左浮动 navbar-right ☞ 右浮动 6. 导航条里面单独的按钮和链接 按钮 ☞ navbar-btn 链接 ☞ navbar-link和navbar-text 普通文字 ☞ navbar-text 7. 固定导航条 navbar-fixed-top|navbar-fixed-bottom ☞ 响应式导航条 1. 将nav导航用一个类名为collapse和navbar-collapse的div包起来 2. 在navbar-header里添加类名为navbar-toggle和自定义属性为data-toggle=&quot;collapse&quot;与data-target=&quot;#myNav（自己取名）&quot;的按钮，在按标签里再加入汉堡按钮 汉堡按钮：三个span标签，每个类名为icon-bar bootstrap标签/徽章 通过span标签，添加类名label ☞ 基础类名 label-default label-primary label-success ... 通过span标签，添加类名bodge bootstrap内置组件缩略图 使用网格系统实现 警示框若在警告框里的文字加链接，则会覆盖原有警示框颜色，应该在a标签里加类名alert-link 给警示框加类名alert-dismissable 给警示框加类名为close的button标签 按钮上加自定义属性data-dismiss=”alert” 进度条 外层div用来写灰色背景，类名progress 加类名progress-striped为条纹进度条 再加active类名为动态进度条 里层div显示进度，类名progress-bar ☞ 基础类名 progress-bar-success ... 给progress-bar加行内样式width=百分比 bootstrap多媒体对象 加一个类名为media的div容器 在media的div中加一个类名为pull-left的a标签 在media的div中添加媒体描述，使用类名为media-body的div 给媒体body中的标题加media-heading类名 要放置多个媒体列表，则在所有列表外套一个类名为media-list的div 在media-dody中再写入media的div则为媒体嵌套 bootstrap列表组 基础列表组 给无序列表或div加类名list-group，给li列表项加类名list-group-item 在列表组里加徽章，bodge，自动的右浮动 自定义列表 li添加标题元素类名为list-group-item-heading放置标题和h标签 再加入类名为list-group-item-text的p标签来放内容 bootstrap面板基础面板 添加类名为panel的div容器，其中panel为基础类名 在panel里添加类名为panel-heading的div，在其中添加类名为panel-title的标题h1~h6 在panel里添加一个类名为panel-body的div放主内容，表格，表单等 在panel-body后添加类名为panel-footer的div，在其中添加普通文字 bootstrap插件 以下插件若通过js调用的话，均不必添加任何自定义属性 模态弹出框 通俗点就是alert弹出框，只不过样式花哨点 结构分析123456.modal .modal-dialog .modal-content .modal-header .modal-body .modal-footer 模态框默认为隐藏状态 触发方式 给触发元素（按钮）添加属性data-toggle=”modal”和data-target=”#myModal（自己取名）” a标签加href=”#myModal”和data-toggle=”modal” js触发 1$('#myModal').modal(); 给模态框添加动画效果：在modal类名上的div中再增加fade类 当data-backdrop=&quot;static&quot;时，点击modal之外的地方不会使其消失 其他参数 通过标签属性和js参数传递，通过js，则去掉data-*属性，只传入后面的名称$(&apos;#myModal&apos;).modal();只传入modal括号内就好 data-backdrop ☞ true|false ☞ 弹出框是否有大背景，默认true data-keyboard ☞ true|false ☞ 按下Esc键是否可以关闭模态框需要同时设置属性tabindex=”-1” 滚动监听 创建一个导航，添加id属性 给导航中的li中的a标签添加href值对应到每一个模块 给body添加属性data-spy=”scroll”和data-target=”#myNavbar（自己取名）” 固定定位：在需要固定的元素加属性data-spy=&quot;affix&quot;和data-offset-top=&quot;数值&quot; 提示框 给需要提示的标签添加属性data-toggle=”tooltip”，title=”提示” 通过js调用提示框插件 1tooltip(); 控制提示框的方向：添加属性data-placement=”top|bottom|left|right” 弹出框 给需要弹出框的元素加属性data-toggle=”popover”和data-content=”弹出框内容”，title=”标题内容” 警示框 创建一个警示框alert 在其中加入关闭按钮 用警示框外的按钮来关闭它 在外部元素添加属性data-dismiss=”alert”和data-target=”#自己取名” 按钮 模拟单选按钮 在btn-group中添加data-toggle=”buttons” 模拟复选框 同上，把input的type类型换成checkbox即可 按钮状态切换 给button添加属性data-toggle=”button” 通过js调用 1$('selector').button('toggle'); 加载状态按钮 当点击时，按钮状态变为加载中，文本变成data-toggle-text的内容 12$('selector').button('toggle');$('selector').button('reset');//写入setTimeout函数中去 手风琴插件使用 添加一个类名为panel-group的div作为面板组的内容 在面板组里面添加面板，并且为面板定义头部和主体内容 在panel-title里添加一个a标签，加属性data-toggle=”collapse”和data-parent=”#面板组id”，href=”#面板内容id” 将panel-body用类为panel-collapse和collapse的div包起来，并设置id 给指定面板加类名in，则为默认展开状态 轮播图插件使用 添加类名为carousel和slide的div，作为轮播图容器，设置id 添加计数器，默认样式为圆点，可用无序列表实现，为其添加类名carousel-indicators，为每个li加属性data-target=”#容器id”和data-slide-to=”0~n”，对应每一张图 添加一个类名为carousel-inner的div容器，用来存放图片，每张图放在类名为item的div中 给对应的item项和对应的圆点加active为默认显示的状态 添加两个类名为carousel-control的a链接，分别加类名left|right，在其中加属性data-slide=”prev”或next，并设置href=”#容器id” 给carousel加data-ride=”carousel”使其自动轮播data-interval=”毫秒数” ☞ 控制轮播图自动轮播切换间隔时间data-wrap=”true|false” ☞ 是否循环轮播 js控制轮播： $(&apos;selector&apos;).carousel();参数同上一条的data属性 $(&apos;selector).carousel(&apos;pause|prev|next&apos;);暂停|上一张|下一张 轮播事件： $(&apos;selector&apos;).on({ &apos;slide.bs.carousel&apos;:function(){ ... 切换前事件 }, &apos;slid.bs.carousel&apos;:function(){ ... 切换后事件 } })]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery常用语法]]></title>
      <url>%2F2017%2F01%2F06%2FjQuery-common%2F</url>
      <content type="text"><![CDATA[首先附上jQuery官网http://jquery.com/2.0版本开始放弃了对IE7/8及其之前版本的兼容 准备工作 文件引入 必须引入jQuery库文件，引入方法与普通js文件一样 jQuery基本语法 单双引号通用 $(&#39;selecter&#39;).function(参数) $符号代表jQuery,是jQuery的缩写 隐式迭代：获取一组标签，不需要遍历循环，即可直接操作 链式操作：不需要重复获取标签元素，在一个操作后面直接跟另一条命令jQuery每一个操作函数返回值均为object，所以才可以使用链式操作 文档就绪 jQuery文档就绪 $(document).ready()或者简写为：$(function{}) 与原生JS文档就绪比较 window.onload vs $(function{}) 前者必须等网页中所有的元素（包含图片、flash、视频等）全部加载完毕后执行，而后者等所有的DOM文档结构绘制完毕后即刻执行，不需要等待图片、flash等DOM大标签加载完毕就执行，如p、h、body、div等加载完就执行 一个页面只允许存在一个window.onload，而可以存在多个$(function{}) jQuery 选择器 基本选择器 标签选择器$(&#39;p&#39;) or $(&#39;div&#39;) 类选择器$(&#39;.class&#39;) ID选择器$(&#39;#id&#39;) 群组选择器$(&#39;div,span,p&#39;) 交集选择器$(&#39;p.top&#39;)选取类名为top的p标签 全局选择器$(&#39;*&#39;) 特殊情况 $(document) $(window) $(&#39;body&#39;) $(this)页面中的标签需要加引号或者双引号 层次选择器 后代选择器$(&#39;#box span&#39;) 子级选择器$(&#39;#box&gt;span&#39;) 紧邻同辈选择器$(&#39;#box+p&#39;)id名为box的后面一个p标签 相邻同辈选择器$(&#39;#box~p&#39;)id名为box的后面所有p标签 属性选择器 $(&#39;[name]&#39;)选择所有具有name属性的标签元素 $(&#39;[name=user]&#39;)所有name=user的标签 $(&#39;[name!=user]&#39;)name不等于user $(&#39;[name^=user]&#39;)以user开头 $(&#39;[name$=user]&#39;)以user结尾 $(&#39;[name][id]&#39;)选择同时具有name和id的元素class、type、id等均为属性 过滤选择器 :first$(&#39;ul li:first&#39;) :last$(&#39;ul li:last&#39;) :even 从0开始，选择集合中的偶数行 :odd 同上，选择奇数行 :eq(n) n从0开始计数 gt(n) 集合中第n个后的元素/大于n的元素，从0开始计数 lt(n) 同上反 :not(selector)$(&#39;ul li:not(:eq(3))&#39;)选择不包含selector中的元素 :header 选择所有h1~h6的标题元素 :visible 可见元素 :hidden 不可见元素 :first-child 列表中的第一个元素，相对于本 身父元素 :first-of-type 列表中同类型元素 :nth-c hild(n) 列表中第n个元素，从1开始计数 :nth-last-child(n) 倒序计数第n个元素 :nth-of-type(n) 列表中同类型的第n个子元素，从1开始计数 :empty 空元素 :parent 含有子元 素或文本的元素 :has(selector)$(&#39;div:has(h 2 )&#39;) 匹配包含h2的div :contains(text)$(&#39;:contains(hello)&#39;) 匹配包含hello的元素 常用的过滤方法（function） get(i) 选择第i个元素，返回DOM对象不能采用jQuery写法$(&#39;h2&#39;).get(2)正确写法：$(&#39;h2&#39;).get(2).style.color = &#39;red&#39; eq(i) 选择第i个元素，返回jQuery对象可以采用jQuery写法$(&#39;h2&#39;).eq(2)正确写法：$(&#39;h2&#39;).eq(2).css(&#39;color&#39;,’red’) first()|last() 选择第一个|最后一个元素 not(selector) 同not选择器$(&#39;h2&#39;).not(&#39;:contains(hello)&#39;) has() 同has选择器 find(selector) 获取当前匹配元素集合中每一个元素的后代，同has选择器，但返回的是find中的标签，而不是像has的父级元素 表单选择器 :input 表单元素，包括input、textarea、select、button :text 单行文本框元素，只能匹配type=text的文本框 :password :radio 单选按钮 :checkbox 复选框 :submit type=submit和button标签 :image type=’image’的input图像域 :reset :button :file :checked :focus 焦点所在元素 DOM对象和jQuery对象 jQuery对象转化成 DOM对象 jQuery对象可以理解为由DOM元素组成的一个数组 get(i)jQuery对象.get(i) jQuery对象[i]因为通过jQuery获取的对象类似于一个数组 DOM对象转化成jQuery对象 将DOM获取到的对象变量用小括号包起来，前面加$$(DOM对象) jQuery事件 jQuery常用事件 鼠标事件 点击事件 click dblclick 双击 mousedown mouseup 移动事件 mouseover 移入该元素和对应的子元素 mouseout 移出该元素和对应的子元素 mouseenter 移入该元素，不对其子元素生效 mouseleave 移出该元素，不对其子元素生效 mousemove 鼠标每移动一个像素就会触发一次 组合事件 hovermouseenter+mouseleavejQuery1.8版本之后改为mouseover+mouseout 键盘事件 keydown keyup keypress 产生可打印的字符时触发，不包括中文 表单事件 focus 获得焦点 submit blur 失去焦点 change 事件绑定与移除 事件绑定 直接通过事件名绑定$(selector).事件名() bind() 绑定一个事件：bind(‘事件类型’,function(){});同直接绑定 绑定多个事件：$(selector).bind({事件类型1:function(){},事件类型2:function(){},…})绑定一个事件：每用一次事件查找一次绑定多个事件：只需要查找一遍元素 one()绑定一次性事件，比如按钮点击后自动不再具有点击效果，写法同bind绑定 on()类似于bind绑定，比bind多一个参数(selector)，可实现动态更新事件（页面加载完后新增加的元素也可实现此事件方法，而bind无法响应页面加载后新增的元素） 123456$('ul').on('click','li',function()&#123; alert($(this).text);&#125;); //动态绑定$('ul li').bind('click',function()&#123; alert($(this).text); //静态绑定&#125;); 事件移除 unbind()不传参数，则默认移除所有事件unbind([type],[function]) 一个参数：可以指定移除事件类型 两个参数：可以指定移除某个事件其中的某个响应方法 off()同on()相对应 事件的命名空间 在bind绑定事件中，在事件类型中，使用事件类型命名来创建同一个事件的多个名字，如click.a,click.b…命名空间后要加引号，如’click.a’,’click.b’ 模拟事件 trigger()自动触发事件，传入参数为事件类型链式写法：$(selector).trigger(&#39;事件类型&#39;) triggerHandler()同上，区别为： 不会执行事件的默认行为，比如表单的功能按钮和链接标签 只触发jQuery对象集合中的第一个元素的事件处理函数，比如无序列表下的li集合，只触发第一个li 返回值为undefined，trigger返回jQuery对象，无法继续在其后增加链式操作 阻止了事件冒泡使用传入事件event参数event.stopPropagation()也可以达到阻止事件冒泡功能 event对象 event只有事件处理函数能够访问，当事件处理完毕后，event就会自动销毁 event常用属性 type clientX|clientY窗口可视化区域x和y坐标 pageX|pageY相对于文档的x和y坐标，y坐标算上滚动条坐标 offsetX|offsetY相对于事件源的坐标，在哪个标签内就获取这个标签内的x，y坐标 screenX|screenY屏幕的x，y坐标 keyCode检测键盘事件相对应的内码 target返回触发该事件的DOM元素比如标签h、p、div…元素 event常用方法 preventDefault()阻止默认行为 stopPropagation()阻止事件冒泡行为 jQuery动画 显示/隐藏 show() hide()可传入参数：’slow’、’normal’、’fast’，或者毫秒数 toggle()一个按钮两种方式切换，再点击可隐藏 淡入/淡出 fadeIn() fadeOut()不传参数有默认动画，但速度很快 fadeToggle同toggle() 改变元素高度 slideUp()高度由大到小slideDown()高度由小到大 slideToggle()同toggle() 自定义动画 animate(param,speed,easing,callback)param：改变css一组样式属性名称和值得集合，只有数值型的属性可执行speed：’slow’、’fast’，或者毫秒数easing：’linear’匀速、’swing’由快到慢 操作动画的方法： stop()停止元素正在执行的动画暂停 finish()立即结束动画立刻到达动画的终点结束 delay()延迟执行动画效果 jQuery样式操作 样式设置与获取 获取样式$(selector).css(属性名称)传一个参数返回的为字符串类型，带有属性自带的单位值 设置样式$(selector).css({&#39;color&#39;:&#39;red&#39;,&#39;font&#39;:&#39;16px&#39;,...}) 在jQuery中设置数值类型样式可省略引号与单位,样式名称也可去掉引号，但遇到长单词需改用驼峰写法 通过类名来控制样式 addClass(&#39;className&#39;)添加样式，通过类名增加样式多个类名：`addClass(‘className1’ ‘className2’ …) removeClass()方法同上，移除类名 toggleClass()切换类名 快速获取和设置样式 .width() .height()返回number类型，若传参，则为设置宽度和高度 innerWidth() innerHeight()设置和获取元素的内宽度和内高度，包含padding，不含margin和border outWidth() outHeight()设置和获取元素的外高度和外宽度，包含padding和border当传入参数为true，返回值包含margin offset()设置或返回一个元素相对于文档的left和right，返回的是left和right的对象集合 position()相对于该元素的父元素的left和right scrollTop() scrollLeft()设置于滚动条顶部和左部的偏移 12$('html,body').scrollTop();//设置,IE+FF为html，chrome为body$(window).scrollTop();//获取 jQuery内容和属性操作 html()类似于原生js中的innerHtml 123获取和设置元素的内容，包含HTML标签将HTML标签和里面的文字以字符串形式完全获取出来比如段落内为hello，获取到的返回值为&lt;p&gt;hello&lt;/p&gt; 传入参数，即改为设置新内容，会覆盖原先的内容 text()类似于原生js里的innerText获取和设置元素内的文本内容，不含html标签，内容为hello的段落，获取到的返回值为hello传入参数，即为设置新内容，会覆盖原先的内容 val()同原生js中的value() attr()元素属性 传入一个参数，获取属性 两个参数，设置单个属性attr(name,value) 多个参数，设置多个属性 removeAttr()移除属性，传入属性名称即可 prop()类似于attr()主要作用于select、radio、checkbox，选中则返回trueremoveProp()移除属性 jQuery对于节点的操作 创建节点 $(selector)通过选择器获取节点 $(element)把dom节点转换成jQuery节点 $(html代码) $(&#39;&lt;p&gt;hello&lt;/p&gt;&#39;) 在元素内部插入节点 append() a.append(b) b元素插入到a元素中 appendTo() prepend() prependTo 在元素外部插入节点 after() a.after(b) b元素插入到a元素的后面 insetAfter() before() insetBefore() 包裹节点 wrap()将所匹配的元素用其他元素包裹起来 unwrap()移除一个元素的父元素 wrapAll()将所有元素用一个标签包裹起来 wrapInner()将匹配的元素的子元素（包含节点和文本）用其他元素包裹 替换节点 a.replaceWith(b)把a元素替换成b元素 a.replaceAll(b)同上反 克隆节点 clone()用于复制节点，复制出的节点不带有原有元素的事件，当传入参数为true时，复制元素并复制原有的事件 删除节点 remove() detach()删除节点，保留原有数据和事件，同clone(true) empty()清空节点内的内容，不删除此节点 jQuery遍历元素 获取同辈元素 next()获取紧邻元素后面的元素 nextAll()获取元素后面所有同级元素 prev()紧邻前面一个元素 prevAll()元素前面所有元素 siblings()元素前后所有同级元素 获取前辈元素 parent()获取元素的父级元素(从父级开始遍历) parents()获取元素所有的祖先元素(从父级开始遍历) closest()参数必传，获取匹配选择器的第一个祖先元素(从自身开始遍历) 获取子元素 children()获取一个元素的所有子元素，但是不包含子元素的子元素 find(selector)获取所有匹配元素的子元素 contents()当前所有的子节点（文本节点+注释节点）一般用于获取iframe框架内容 遍历 each()对jQuery对象进行迭代，为每一个元素执行函数 123each(function(index,element) &#123; ...&#125;) index()获取元素的下标位置 is()判断当前元素是否符合选择器的条件，必传参数selector，匹配成功则返回true jQuery插件封装 $.extend() 一个参数：用于扩展jQuery类本身，为jQuery类添加新方法 123456789 $.extend(&#123; &apos;functionName1&apos;:function()&#123; ... &#125;, &apos;functionName2&apos;:function()&#123; ... &#125;, ...&#125;) 多个参数：用于合并对象 浅拷贝：第一个参数可以传入空对象，那么原来的值就不会被后面的对象覆盖$.extend(obj1,obj2,obj3...) 深拷贝：第一个参数传入true对象内包含对象，则会进行合并，并不会覆盖值 $.fn.extend()用来扩展$元素的对象的方法 jQuery命名冲突 当另一个js插件库中也有$符号的存在，则会发生名字冲突 jQuery.noConflict()放弃jQuery对命名的使用权 将$全部用全称jQuery代替 用新的变量作为$符号使用var $$=jQuery 使用代码块，在代码块中仍可使用$符号 插件库命名规范：jQuery.插件名字.版本号.js jQuery-ajax ajax简易方法 $.get(url,data,callback,type)dada：需要发送的参数{key:value}callback：指定成功时的回调函数type：指定返回内容的格式（xml，html，script，json，string） $(selector).load(url)加载html，不需要回调函数即可加载到所选元素中 $.getScript()加载脚本文件 $.getJSON加载json文件 $.ajax() 12345678910 $.ajax(&#123; &apos;type&apos;:&apos;get&apos;, &apos;url&apos;:&apos;&apos;, async:true, //默认为true，可不写 data:&#123;&#125;, //发送到服务器的数据 dataType: , //预期服务器返回的数据类型 success:callback, error:callback, ...&#125;) ajax参数详解 type 请求方式，默认为get url data key:value格式 dataType 返回的数据类型，如：json，不指定则jQuery自动断定 cache 是否缓存，默认为true，当dataType为script与jsonp【跨域用途】时cache默认false global 是否触发ajax全局事件，默认true jsonpCallback 为jsonp请求指定一个回调函数的名称 context 用于指定$(this)所指向的对象 success 请求成功时所执行的操作function error 失败时，同上 complete function函数，请求完成后执行，不管成败success:function(data,textStatus,xhr)error:function(xhr,textStatus,errormsg)complete:function(xhr,textStatus) 123data：请求地址返回的数据textStatus：请求状态的文字说明xhr：xmlHTTPRequest对象 beforeSend function(xhr)发送请求之前调用 username|password 响应HTTP访问认证请求的用户名和密码 ajax全局设置 用于设置全局ajax默认选项（当需要多次使用ajax请求时，有些默认参数是一样的，可以通过全局一次性设置）$.ajaxSetup({同ajax参数})设置后不会发送请求，只是设置，所以$.ajax()还是要写一遍 全局事件：$(document).ajaxComplete(function(){});$(document).ajaxSuccess(function(){});$(document).ajaxError(function(){});$(document).ajaxStart(function(){});$(document).ajaxSend(function(){});$(document).ajaxStop(function(){});function内参数为：event，xhr，options 序列化数据使用序列化方法时表单必须加一个name属性 serialize() 序列化表单内容，将表单内容转化为字符串 serializeArray() 序列化表单内容，返回数据格式 jQuery-jsonp跨域 同源策略：浏览器不能向不同域的地址提交请求 远程获取数据 script的src属性 img的src属性 iframe的src属性 jsonp跨域 可以让网页从别的域名（网站）获取资料，只支持get请求设置☞dataType:’jsonp’,jsonpCallback:’自己命名(服务器的function名称，不传参数，服务器会自动生成一个随机名)’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[user]]></title>
      <url>%2F2017%2F01%2F06%2Fuser%2F</url>
      <content type="text"><![CDATA[CodeAliyun username:wo_xiaofan GitHub username:woxiaofan email:wo_xiaofan165@163.com Gmail username:woxiaofan165@gmail.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git+nodejs搭建web静态服务器]]></title>
      <url>%2F2017%2F01%2F06%2Fgit%2Bnodejs%2Bweb%2F</url>
      <content type="text"><![CDATA[搭建web静态服务器创建项目根目录（或者从github仓库clone）并创建node项目初始化执行此步骤前提条件为：①有过项目，但是使用环境更改的，比如更换电脑等②没有项目，但是有package.json文件的 ps:以上条件不满足者从头老老实实搭建项目结构+安装各种插件（下文） 满足条件的还需要两个js配置文件，请拉倒最下面附录！ npm init按默认要求敲击enter键 - name[可修改] - version [可修改] - description[可不写] - entry point[可不写] - text command[暂时不写] - git repository[git仓库地址] - keywords[可不写] - author[可不写] - license[默认] 安装express包，属于项目依赖 npm install express --save成功标志：出现node_modules文件夹 安装gulp包，属于开发依赖 npm install gulp -g 取消默认扫描此步骤针对webstorm以及类似的编译器：由于上传文件和检查代码过程中编译器会自动检索node_modules包，因为操作量巨大极可能导致编译器卡死甚至电脑死机现象，此步骤必点！ 在编译器中右击node_modules文件夹选择Mark Directory As Exclusion（取消自动扫描） 创建项目详细结构（从原本项目仓库clone者忽略这步骤） 新建入口文件 server.js 新建public/ 文件夹，用来存放静态文件css、js、img等 新建views/ 文件夹，用来存放html文件 新建routes/ 文件夹，用来存放路由文件[用来接受请求] 新建 .gitignore文件[忽略不必要的上传] node_modules/ .project .idea/ *.exe logs/ .vscode/ *.log *.bak … 新建stylus/ 文件夹，用来存放styl文件 gulp 基本操作基本命令 gulp.task[创建一个任务] gulp.src[获取要处理的文件或目录-待定匹配模式] gulp.dest[处理后的文件输出] gulp.watch[动态监听文件更改] 配置文件gulpfile.js[不可改，特定名称] 引入gulp等所需模块或插件 创建任务 创建编译stylus 文件/压缩文件等等 监听文件变更 安装所需插件 npm install gulp-stylus --save-dev安装stylus自动编译 npm install gulp-minify-css --save-dev安装css压缩插件 npm install gulp-uglify --save-dev安装js压缩插件 npm install gulp-nodemon --save-dev启动node插件，不需要每次手动去启动 npm install browser-sync --save-dev代理，自动刷新页面 可能用到的git命令如下 git rm -r --cached&lt;filename&gt;停止git追踪指定文件夹或文件 git pull origin master获取远程仓库更新 mkdir&lt;name&gt;创建一个目录 ls查看当前目录下的文件及其目录 ls -a同上，包含隐藏文件 git init git add . git commit -m &#39;message&#39; git config --global user.email &#39;email&#39; git config --global user.name &#39;name&#39; git config --list git status Stylus css预处理框架，使用表达式生成css 另外常用两款框架： sass 最早最成熟的css预处理语言 less 受sass影响很大且使用css语法，易上手 手动编译 通过cmd控制台进入到项目文件夹（不想吐槽win系统自带的控制台，推荐使用Git） 执行命令stylus --compress styl所在文件夹目录compress：生成压缩版的css文件stylus --compress styl所在文件夹目录/ --out css文件夹目录输出到另一个css目录文件夹下 css转换成styl文件： stylus --css css所在目录/css文佳全称 styl文件目录/styl文件全称 ps:若输出到同一目录下的相同名称的styl文件，则不需要styl文件目录/styl文件全称 自动编译 以下步骤当项目静态服务器搭建好后应该已经执行完，不用去管 gulp安装cnpm install gulp -ggulp -v查看是否成功 配置json文件进入项目根目录，新建package.json文件 本地安装gulp插件cnpm install gulp --save-dev在根目录下出现node_modules/文件夹则代表安装成功 安装gulp-stylus插件cnpm install gulp-stylus --save-dev 新建gulpfile.js文件 Stylus语法 单行注释不会被编译到css中，而多行注释会被自动编译到css中 去除原生css中的{}和:和;使用首行文字+换行缩进的格式，嵌套的标签继续前一级缩进 &amp;符号:代表父级，h标签下的类名为h缩进后&amp;.类名 可以使用变量scolor = red以下所有需要使用红色的地方可直接使用scolor作为属性样式的颜色 @符号：可以计算数值height 800pxwidth (@height/2)有运算符时必须加括号@引用会冒泡向上寻找离@最近的，直到父级为止 当使用css3兼容性样式时，前缀样式可以用一个方法封装起来 border-radius(val) 使用时，调用border-radius(10px) 迭代(循环遍历)for in 包含边界：1..5 &gt;&gt;&gt; 1 2 3 4 5 不包含边界：1...5 &gt;&gt;&gt; 1 2 3 4 123for row in 1..5 tr:nth-child(&#123;row&#125;) height 10px*row @import 引入外部文件@import’demo.css’写在.styl文档最顶端@import’demo’不加后缀默认为引入.styl文件 @font-face 引入字体文件 @font-face font-family myFont(自己取名) src url() url() url() PS:通常字体文件共4个，全部导入，为了满足不同的浏览器 ------------------------------------------------- @media 指定媒体类型 @media all 所有类型 screen 电脑屏幕 print 打印机 max-width min-width [max-]device-width/device-height 设备宽度 @media 关键词： and/only 限定关键词/not @media only screen and (min-width:800px){} 当浏览器屏幕大于800px时所表现的样式，这行代码要写在整体样式后，不然会被覆盖 ------------------------------------------------- @keyframes myAnimate(自己取名) 0% ... 50% ... 100% ... 0% ... 附录项目结构 若你使用的项目和我不同，为了实现自动编译和自动刷新效果，请在两个js文件里做更改 gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Created by Administrator on 2017/01/04. */var gulp = require('gulp');var stylus = require('gulp-stylus');// var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var nodemon = require('gulp-nodemon');var browserSync = require('browser-sync').create();var reload = browserSync.reload;//编写一个编译stylus任务gulp.task('stylus',function () &#123; //stylus文件及其所有子目录的文件 return gulp.src('./stylus/**/*.styl') //编译stylus文件 .pipe(stylus()) //输出stylus编译后的文件 .pipe(gulp.dest('./public/css/'))&#125;);gulp.task('minifycss',['stylus'],function () &#123; return gulp.src('./public/css/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public/mincss/'))&#125;);gulp.task('uglify',function () &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public/minjs/'))&#125;);/*不用每次都启动app.js，只需要启动watcher任务即可*/gulp.task('nodemon',function (nm) &#123; var flag = false; return nodemon(&#123; script:'./server.js' &#125;).on('start',function () &#123; if(!flag)&#123; nm(); flag = true; &#125; &#125;)&#125;);gulp.task('browserSync',['nodemon'],function () &#123; browserSync.init(&#123; proxy:&#123; target:'http://127.0.0.1:16909' &#125;, files:['*'], port:9888, open:false &#125;)&#125;);//动态监听gulp.task('watcher',['browserSync','stylus'],function () &#123; gulp.watch('./stylus/**/*.styl',['stylus']); gulp.watch('./public/css/**/*.css').on('change',function () &#123; reload(); &#125;)&#125;); server.js1234567891011121314151617181920212223var path = require('path');//引入express依赖模块，用来启动静态服务器var express = require('express');/*console.log(__dirname);*/var proxy = require('http-proxy-middleware');//实例化expressvar app = express();app.use('/api',proxy(&#123; target:'http://122.10.30.153:9901', pathRewrite:&#123; '^/api':'/' &#125;&#125;));//指定访问页面路径app.use('/',express.static(path.join(__dirname,'views')));app.use('/public',express.static(path.join(__dirname,'public')));//指定端口号，建议3000以上,回调函数可以不写app.listen(16909,function ()&#123; console.log('server run at port 16909')&#125;);//模块导出module.expotrs = app; package.json1234567891011121314151617181920212223&#123; "name": "h5", "version": "1.0.0", "description": "", "main": "gulpfile.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" &#125;, "author": "yyf", "license": "ISC", "dependencies": &#123; "express": "^4.14.0" &#125;, "devDependencies": &#123; "browser-sync": "^2.18.6", "gulp": "^3.9.1", "gulp-nodemon": "^2.2.1", "gulp-stylus": "^2.6.0", "gulp-uglify": "^2.0.0", "http-proxy-middleware": "^0.17.3" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github博客搭建简易步骤]]></title>
      <url>%2F2017%2F01%2F06%2Fhexo%2Bgithub%2Bblog%2F</url>
      <content type="text"><![CDATA[1.首先你得有一个自己的github账户教学点击这里2.其次你要拥有git和nodejs的环境配置，这里就不详细介绍了 Hexo配置 npm install hexo-cli -g 安装工具 mkdir dirname 创建blog目录(不创建的话默认为source中的_posts文件夹) cd dirname 进入目录 hexo new &#39;file name&#39; 新建md文件 hexo init 初始化hexo npm install 安装依赖 npm install hexo-deployer-git –save 安装git发布插件 创建github仓库，用户名.github.io 配置 _config.yml，添加如下： 1234deploy: type: git repo: github地址（ssh地址） branch: master hexo g 生成页面 hexo s 启动本地预览服务器 hexo d 发布到github hexo n ‘name’ 新建blog 访问路径 用户名.github.io github二级域名访问页面 修改github项目结构，确保主目录下有一个index.html文件（非必要） 在github里创建一个名叫gh-pages的特定分支 直接在浏览器中输入&lt;用户名.github.io/项目文件名[/index.html]&gt; 不过通过github访问，怎么看都不是自己想要的结果，试想，要是有一个属于自己的一个域名，www.域名.com直接访问你的博客，那多cool！ 打造博客专属域名 首先你要有个域名，那么就要去申请域名了，这里我们可以通过万网申请查找你想申请域名，如果可以买，购买就可以了 域名解析 购买域名完成，进入万网的管理控制台 找到你已经购买的域名，点击如上箭头解析，进入如下页面 然后点击添加解析，ip可以选择默认192.30.252.154，当然以防发生变化，你可以ping你的urlping www.你的github用户名.github.io在cmd控制台拿到ip值 主机记录www对应www.ityyf.com 主机记录@对应ityyf.com 域名修改 我们通过简易手段DNSpod自动修改工具 注册DNSpod，添加域名，添加记录，如下图设置 在source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：ityyf.com（注意前面不添加http://） hexo d发布blog试试效果吧！]]></content>
    </entry>

    
  
  
</search>
